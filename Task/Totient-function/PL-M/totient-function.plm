100H:
BDOS: PROCEDURE (F,A); DECLARE F BYTE, A ADDRESS; GO TO 5; END BDOS;
EXIT: PROCEDURE; GO TO 0; END EXIT;
PRINT: PROCEDURE (S); DECLARE S ADDRESS; CALL BDOS(9,S); END PRINT;

PRINT$NUM: PROCEDURE (N);
    DECLARE (N, P) ADDRESS, CH BASED P BYTE;
    DECLARE S (6) BYTE INITIAL ('.....$');
    P = .S(5);
DIGIT:
    P = P-1;
    CH = '0' + N MOD 10;
    IF (N := N/10) > 0 THEN GO TO DIGIT;
    CALL PRINT(P);
END PRINT$NUM;

TOTIENT: PROCEDURE (N) ADDRESS;
    DECLARE (TOT, N, I) ADDRESS;
    TOT = N;
    I = 2;
    DO WHILE I*I <= N;
        IF N MOD I = 0 THEN DO;
            DO WHILE (N := N / I) MOD I = 0; END;
            TOT = TOT - TOT / I;
        END;
        IF I=2 THEN I=1;
        I = I+2;
    END;
    IF N > 1 THEN TOT = TOT - TOT / N;
    RETURN TOT;
END TOTIENT;

SHOW$PRIME$COUNT: PROCEDURE (N, COUNT);
    DECLARE (N, COUNT) ADDRESS;
    CALL PRINT(.'THERE ARE $');
    CALL PRINT$NUM(COUNT);
    CALL PRINT(.' PRIMES UP TO $');
    CALL PRINT$NUM(N);
    CALL PRINT(.(13,10,'$'));
END SHOW$PRIME$COUNT;

DECLARE (N, TOT) ADDRESS;
DECLARE PRIME$COUNT ADDRESS INITIAL (0);

DO N = 1 TO 25;
    CALL PRINT(.'PHI($');
    CALL PRINT$NUM(N);
    CALL PRINT(.') = $');
    CALL PRINT$NUM(TOT := TOTIENT(N));
    IF TOT = N-1 THEN DO;
        CALL PRINT(.'; PRIME$');
        PRIME$COUNT = PRIME$COUNT + 1;
    END;
    CALL PRINT(.(13,10,'$'));
END;

CALL SHOW$PRIME$COUNT(25, PRIME$COUNT);
DO N = 26 TO 10000;
    IF TOTIENT(N) = N-1 THEN
        PRIME$COUNT = PRIME$COUNT + 1;
    IF N=100 OR N=1000 OR N=10000 THEN
        CALL SHOW$PRIME$COUNT(N, PRIME$COUNT);
END;

CALL EXIT;
EOF
