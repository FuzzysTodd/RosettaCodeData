100H:
BDOS: PROCEDURE (F,A); DECLARE F BYTE, A ADDRESS; GO TO 5; END BDOS;
EXIT: PROCEDURE; GO TO 0; END EXIT;
PR$CHAR: PROCEDURE (C); DECLARE C BYTE; CALL BDOS(2,C); END PR$CHAR;
PRINT: PROCEDURE (S); DECLARE S ADDRESS; CALL BDOS(9,S); END PRINT;

PR$NUM: PROCEDURE (N, WIDTH);
    DECLARE N ADDRESS, WIDTH BYTE;
    DECLARE S (6) BYTE INITIAL ('.....$');
    DECLARE P ADDRESS, DG BASED P BYTE;
    P = .S(5);
DIGIT:
    P = P - 1;
    DG = '0' + N MOD 10;
    IF WIDTH > 0 THEN WIDTH = WIDTH - 1;
    IF (N := N / 10) > 0 THEN GO TO DIGIT;
    CALL PRINT(P);
    DO WHILE WIDTH > 0;
        CALL PR$CHAR(' ');
        WIDTH = WIDTH - 1;
    END;
END PR$NUM;

DECLARE MAX$SIGMA LITERALLY '10$001';
DECLARE SIGMA (MAX$SIGMA) ADDRESS;
CALC$SIGMA: PROCEDURE;
    DECLARE (I, J) ADDRESS;
    DO I = 1 TO MAX$SIGMA-1;
        SIGMA(I) = 0;
    END;
    DO I = 1 TO MAX$SIGMA-1;
        DO J = I TO MAX$SIGMA-1 BY I;
            SIGMA(J) = SIGMA(J) + I;
        END;
    END;
END CALC$SIGMA;

GCD: PROCEDURE (X, Y) ADDRESS;
    DECLARE (X, Y, Z) ADDRESS;
    DO WHILE Y > 0;
        Z = X MOD Y;
        X = Y;
        Y = Z;
    END;
    RETURN X;
END GCD;

DUFF: PROCEDURE (N) BYTE;
    DECLARE N ADDRESS;
    RETURN SIGMA(N) > N+1 AND GCD(N, SIGMA(N)) = 1;
END DUFF;

DUFF$TRIPLE: PROCEDURE (N) BYTE;
    DECLARE N ADDRESS;
    RETURN DUFF(N) AND DUFF(N+1) AND DUFF(N+2);
END DUFF$TRIPLE;

DECLARE N ADDRESS, I BYTE;

CALL CALC$SIGMA;
CALL PRINT(.('FIRST 50 DUFFINIAN NUMBERS:',13,10,'$'));
N = 0;
DO I = 1 TO 50;
    DO WHILE NOT DUFF(N := N+1); END;
    CALL PR$NUM(N, 4);
    IF I MOD 10 = 0 THEN CALL PRINT(.(13,10,'$'));
END;

CALL PRINT(.(13,10,'FIRST 15 DUFFINIAN TRIPLES:',13,10,'$'));
N = 0;
DO I = 1 TO 15;
    DO WHILE NOT DUFF$TRIPLE(N := N+1); END;
    CALL PR$NUM(N, 6);
    CALL PR$NUM(N+1, 6);
    CALL PR$NUM(N+2, 6);
    CALL PRINT(.(13,10,'$'));
END;

CALL EXIT;
EOF
